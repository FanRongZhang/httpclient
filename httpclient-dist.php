<?php
/**
 * A parallel HTTP client written in pure PHP
 *
 * This file was generated by script at: 2015/09/10 14:36:00
 *
 * @author hightman <hightman@twomice.net>
 * @link http://hightman.cn
 * @copyright Copyright (c) 2015 Twomice Studio.
 */

namespace hightman\http;
class Client
{
    use HeaderTrait;
    const PACKAGE = __NAMESPACE__ . '\Client';
    const VERSION = '1.0.0-beta';
    const CRLF = "\r\n";
    private $_cookiePath, $_parser, $_timeout;
    private static $_debugOpen = false;
    private static $_processKey;
    public static function debug($msg)
    {
        if ($msg === 'open' || $msg === 'close') {
            self::$_debugOpen = $msg === 'open';
        } elseif (self::$_debugOpen === true) {
            $key = self::$_processKey === null ? '' : '[' . self::$_processKey . '] ';
            echo '[DEBUG] ' . date('H:i:s') . ' ' . $key . implode('', func_get_args()) . self::CRLF;
        }
    }
    public static function gzdecode($data)
    {
        return gzinflate(substr($data, 10, -8));
    }
    public function __construct($p = null)
    {
        $this->applyDefaultHeader();
        $this->setParser($p);
    }
    public function __destruct()
    {
        if ($this->_cookiePath !== null) {
            $this->saveCookie($this->_cookiePath);
        }
    }
    public function setTimeout($sec)
    {
        $this->_timeout = floatval($sec);
    }
    public function setCookiePath($file)
    {
        $this->_cookiePath = $file;
        $this->loadCookie($file);
    }
    public function setParser($p)
    {
        if ($p === null || $p instanceof ParseInterface || is_callable($p)) {
            $this->_parser = $p;
        }
    }
    public function runParser($res, $req, $key = null)
    {
        if ($this->_parser !== null) {
            self::debug('run parser: ', $req->getRawUrl());
            if ($this->_parser instanceof ParseInterface) {
                $this->_parser->parse($res, $req, $key);
            } else {
                call_user_func($this->_parser, $res, $req, $key);
            }
        }
    }
    public function clearHeader()
    {
        parent::clearHeader();
        $this->applyDefaultHeader();
    }
    public function head($url, $params = [])
    {
        return $this->exec($this->buildRequest('HEAD', $url, $params));
    }
    public function mhead($urls, $params = [])
    {
        return $this->exec($this->buildRequests('HEAD', $urls, $params));
    }
    public function get($url, $params = [])
    {
        return $this->exec($this->buildRequest('GET', $url, $params));
    }
    public function mget($urls, $params = [])
    {
        return $this->exec($this->buildRequests('GET', $urls, $params));
    }
    public function delete($url, $params = [])
    {
        return $this->exec($this->buildRequest('DELETE', $url, $params));
    }
    public function mdelete($urls, $params = [])
    {
        return $this->exec($this->buildRequests('DELETE', $urls, $params));
    }
    public function post($url, $params = [])
    {
        $req = $url instanceof Request ? $url : $this->buildRequest('POST', $url);
        foreach ($params as $key => $value) {
            $req->addPostField($key, $value);
        }
        return $this->exec($req);
    }
    public function put($url, $content = '')
    {
        $req = $url instanceof Request ? $url : $this->buildRequest('PUT', $url);
        $req->setBody($content);
        return $this->exec($req);
    }
    public function getJson($url, $params = [])
    {
        $req = $this->buildRequest('GET', $url, $params);
        $req->setHeader('accept', 'application/json');
        $res = $this->exec($req);
        return $res === false ? false : $res->getJson();
    }
    public function postJson($url, $params = [])
    {
        $req = $this->buildRequest('POST', $url);
        $req->setHeader('accept', 'application/json');
        $req->setJsonBody($params);
        $res = $this->exec($req);
        return $res === false ? false : $res->getJson();
    }
    public function putJson($url, $params = [])
    {
        $req = $this->buildRequest('PUT', $url);
        $req->setHeader('accept', 'application/json');
        $req->setJsonBody($params);
        $res = $this->exec($req);
        return $res === false ? false : $res->getJson();
    }
    public function exec($req)
    {
        $recs = [];
        if ($req instanceof Request) {
            $recs[] = new Processor($this, $req);
        } elseif (is_array($req)) {
            foreach ($req as $key => $value) {
                if ($value instanceof Request) {
                    $recs[$key] = new Processor($this, $value, $key);
                }
            }
        }
        if (count($recs) === 0) {
            return false;
        }
        while (true) {
            $rfds = $wfds = $xrec = [];
            $xfds = null;
            foreach ($recs as $rec) {
                self::$_processKey = $rec->key;
                if ($rec->finished || !($conn = $rec->getConn())) {
                    continue;
                }
                if ($this->_timeout !== null) {
                    $xrec[] = $rec;
                }
                $rfds[] = $conn->getSock();
                if ($conn->hasDataToWrite()) {
                    $wfds[] = $conn->getSock();
                }
            }
            self::$_processKey = null;
            if (count($rfds) === 0 && count($wfds) === 0) {
                break;
            }
            self::debug('stream_select(rfds[', count($rfds), '], wfds[', count($wfds), ']) ...');
            if ($this->_timeout === null) {
                $num = stream_select($rfds, $wfds, $xfds, null);
            } else {
                $sec = intval($this->_timeout);
                $usec = intval(($this->_timeout - $sec) * 1000000);
                $num = stream_select($rfds, $wfds, $xfds, $sec, $usec);
            }
            self::debug('select result: ', $num === false ? 'false' : $num);
            if ($num === false) {
                trigger_error('stream_select() error', E_USER_WARNING);
                break;
            } elseif ($num > 0) {
                foreach ($wfds as $sock) {
                    if (!($conn = Connection::findBySock($sock))) {
                        continue;
                    }
                    $rec = $conn->getExArg();
                    self::$_processKey = $rec->key;
                    $rec->send();
                }
                foreach ($rfds as $sock) {
                    if (!($conn = Connection::findBySock($sock))) {
                        continue;
                    }
                    $rec = $conn->getExArg();
                    self::$_processKey = $rec->key;
                    $rec->recv();
                }
            } else {
                foreach ($xrec as $rec) {
                    self::$_processKey = $rec->key;
                    $rec->finish('TIMEOUT');
                }
            }
        }
        if (!is_array($req)) {
            $ret = $recs[0]->res;
        } else {
            $ret = [];
            foreach ($recs as $key => $rec) {
                $ret[$key] = $rec->res;
            }
        }
        return $ret;
    }
    protected function buildRequest($method, $url, $params = [])
    {
        if (count($params) > 0) {
            $url .= strpos($url, '?') === false ? '?' : '&';
            $url .= http_build_query($params);
        }
        return new Request($url, $method);
    }
    protected function buildRequests($method, $urls, $params = [])
    {
        $reqs = [];
        foreach ($urls as $key => $url) {
            $reqs[$key] = $this->buildRequest($method, $url, $params);
        }
        return $reqs;
    }
    protected function defaultAgent()
    {
        $agent = 'Mozilla/5.0 (Compatible; ' . self::PACKAGE . '/' . self::VERSION . ') ';
        $agent .= 'php-' . php_sapi_name() . '/' . phpversion() . ' ';
        $agent .= php_uname('s') . '/' . php_uname('r');
        return $agent;
    }
    protected function applyDefaultHeader()
    {
        $this->setHeader([
            'accept' => '*/*',
            'accept-language' => 'zh-cn,zh',
            'connection' => 'Keep-Alive',
            'user-agent' => $this->defaultAgent(),
        ]);
    }
}
class Connection
{
    const MAX_BURST = 3;
    const FLAG_NEW = 0x01;
    const FLAG_NEW2 = 0x02;
    const FLAG_BUSY = 0x04;
    const FLAG_OPENED = 0x08;
    const FLAG_REUSED = 0x10;
    const FLAG_SELECT = 0x20;
    protected $outBuf, $outLen;
    protected $arg, $sock, $conn, $flag = 0;
    private static $_objs = [];
    private static $_refs = [];
    private static $_lastError;
    public static function connect($conn, $arg = null)
    {
        $obj = null;
        if (!isset(self::$_objs[$conn])) {
            self::$_objs[$conn] = [];
        }
        foreach (self::$_objs[$conn] as $tmp) {
            if (!($tmp->flag & self::FLAG_BUSY)) {
                Client::debug('reuse conn \'', $tmp->conn, '\': ', $tmp->sock);
                $obj = $tmp;
                break;
            }
        }
        if ($obj === null && count(self::$_objs[$conn]) < self::MAX_BURST) {
            $obj = new self($conn);
            self::$_objs[$conn][] = $obj;
            Client::debug('create conn \'', $conn, '\'');
        }
        if ($obj !== null) {
            if ($obj->flag & self::FLAG_OPENED) {
                $obj->flag |= self::FLAG_REUSED;
            } else {
                if (!$obj->openSock()) {
                    return false;
                }
            }
            $obj->flag |= self::FLAG_BUSY;
            $obj->outBuf = null;
            $obj->outLen = 0;
            $obj->arg = $arg;
        }
        return $obj;
    }
    public static function findBySock($sock)
    {
        $sock = strval($sock);
        return isset(self::$_refs[$sock]) ? self::$_refs[$sock] : null;
    }
    public static function getLastError()
    {
        return self::$_lastError;
    }
    public function close($realClose = false)
    {
        $this->arg = null;
        $this->flag &= ~self::FLAG_BUSY;
        if ($realClose === true) {
            Client::debug('close conn \'', $this->conn, '\': ', $this->sock);
            $this->flag &= ~self::FLAG_OPENED;
            @fclose($this->sock);
            $this->delSockRef();
            $this->sock = false;
        } else {
            Client::debug('free conn \'', $this->conn, '\': ', $this->sock);
        }
    }
    public function addWriteData($buf)
    {
        if ($this->outBuf === null) {
            $this->outBuf = $buf;
        } else {
            $this->outBuf .= $buf;
        }
    }
    public function hasDataToWrite()
    {
        return ($this->outBuf !== null && strlen($this->outBuf) > $this->outLen);
    }
    public function write($buf = null)
    {
        if ($buf === null) {
            $len = 0;
            if ($this->hasDataToWrite()) {
                $buf = $this->outLen > 0 ? substr($this->outBuf, $this->outLen) : $this->outBuf;
                $len = $this->write($buf);
                if ($len !== false) {
                    $this->outLen += $len;
                }
            }
            return $len;
        }
        $n = fwrite($this->sock, $buf);
        if ($n === 0 && $this->ioEmptyError()) {
            $n = false;
        }
        return $n;
    }
    public function getLine()
    {
        $line = stream_get_line($this->sock, 2048, "\n");
        if ($line === '' || $line === false) {
            $line = $this->ioEmptyError() ? false : null;
        } else {
            $line = rtrim($line, "\r");
        }
        $this->ioFlagReset();
        return $line;
    }
    public function read($size = 8192)
    {
        $buf = fread($this->sock, $size);
        if ($buf === '' || $buf === false) {
            $buf = $this->ioEmptyError() ? false : null;
        }
        $this->ioFlagReset();
        return $buf;
    }
    public function getSock()
    {
        $this->flag |= self::FLAG_SELECT;
        return $this->sock;
    }
    public function getExArg()
    {
        return $this->arg;
    }
    public function __destruct()
    {
        $this->close(true);
    }
    protected function openSock($repeat = false)
    {
        $this->delSockRef();
        $this->flag |= self::FLAG_NEW;
        if ($repeat === true) {
            $this->flag |= self::FLAG_NEW2;
        }
        $this->sock = stream_socket_client($this->conn, $errno, $error, 1, STREAM_CLIENT_ASYNC_CONNECT);
        if ($this->sock === false) {
            Client::debug($repeat ? 're' : '', 'open \'', $this->conn, '\' failed: ', $error);
            self::$_lastError = $error;
        } else {
            Client::debug($repeat ? 're' : '', 'open \'', $this->conn, '\' success: ', $this->sock);
            stream_set_blocking($this->sock, false);
            $this->flag |= self::FLAG_OPENED;
            $this->addSockRef();
        }
        $this->outBuf = null;
        $this->outLen = 0;
        return $this->sock;
    }
    protected function ioEmptyError()
    {
        if ($this->flag & self::FLAG_SELECT) {
            if (!($this->flag & self::FLAG_REUSED) || !$this->openSock(true)) {
                self::$_lastError = ($this->flag & self::FLAG_NEW) ? 'Fail to connect' : 'Reset by peer';
                return true;
            }
        }
        return false;
    }
    protected function ioFlagReset()
    {
        $this->flag &= ~(self::FLAG_NEW | self::FLAG_REUSED | self::FLAG_SELECT);
        if ($this->flag & self::FLAG_NEW2) {
            $this->flag |= self::FLAG_NEW;
            $this->flag ^= self::FLAG_NEW2;
        }
    }
    protected function addSockRef()
    {
        if ($this->sock !== false) {
            $sock = strval($this->sock);
            self::$_refs[$sock] = $this;
        }
    }
    protected function delSockRef()
    {
        if ($this->sock !== false) {
            $sock = strval($this->sock);
            unset(self::$_refs[$sock]);
        }
    }
    protected function __construct($conn)
    {
        $this->conn = $conn;
        $this->sock = false;
    }
}
trait HeaderTrait
{
    protected $_headers = [];
    protected $_cookies = [];
    public function setHeader($key, $value = null)
    {
        if (is_array($key)) {
            foreach ($key as $k => $v) {
                $this->setHeader($k, $v);
            }
        } else {
            $key = strtolower($key);
            if ($value === null) {
                unset($this->_headers[$key]);
            } else {
                $this->_headers[$key] = $value;
            }
        }
    }
    public function addHeader($key, $value = null)
    {
        if (is_array($key)) {
            foreach ($key as $k => $v) {
                $this->addHeader($k, $v);
            }
        } else {
            if ($value !== null) {
                $key = strtolower($key);
                if (!isset($this->_headers[$key])) {
                    $this->_headers[$key] = $value;
                } else {
                    if (is_array($this->_headers[$key])) {
                        $this->_headers[$key][] = $value;
                    } else {
                        $this->_headers[$key] = [$this->_headers[$key], $value];
                    }
                }
            }
        }
    }
    public function clearHeader()
    {
        $this->_headers = [];
    }
    public function getHeader($key = null)
    {
        if ($key === null) {
            return $this->_headers;
        }
        $key = strtolower($key);
        return isset($this->_headers[$key]) ? $this->_headers[$key] : null;
    }
    public function hasHeader($key)
    {
        return isset($this->_headers[strtolower($key)]);
    }
    public function setRawCookie($key, $value, $expires = null, $domain = '-', $path = '/')
    {
        $domain = strtolower($domain);
        if (substr($domain, 0, 1) === '.') {
            $domain = substr($domain, 1);
        }
        if (!isset($this->_cookies[$domain])) {
            $this->_cookies[$domain] = [];
        }
        if (!isset($this->_cookies[$domain][$path])) {
            $this->_cookies[$domain][$path] = [];
        }
        $list = &$this->_cookies[$domain][$path];
        if ($value === null || $value === '' || ($expires !== null && $expires < time())) {
            unset($list[$key]);
        } else {
            $list[$key] = ['value' => $value, 'expires' => $expires];
        }
    }
    public function setCookie($key, $value)
    {
        $this->setRawCookie($key, rawurlencode($value));
    }
    public function clearCookie($domain = '-', $path = null)
    {
        if ($domain === null) {
            $this->_cookies = [];
        } else {
            $domain = strtolower($domain);
            if ($path === null) {
                unset($this->_cookies[$domain]);
            } else {
                if (isset($this->_cookies[$domain])) {
                    unset($this->_cookies[$domain][$path]);
                }
            }
        }
    }
    public function getCookie($key, $domain = '-')
    {
        $domain = strtolower($domain);
        if ($key === null) {
            $cookies = [];
        }
        while (true) {
            if (isset($this->_cookies[$domain])) {
                foreach ($this->_cookies[$domain] as $path => $list) {
                    if ($key === null) {
                        $cookies = array_merge($list, $cookies);
                    } else {
                        if (isset($list[$key])) {
                            return rawurldecode($list[$key]['value']);
                        }
                    }
                }
            }
            if (($pos = strpos($domain, '.', 1)) === false) {
                break;
            }
            $domain = substr($domain, $pos);
        }
        return $key === null ? $cookies : null;
    }
    public function applyCookie($req)
    {
        $host = $req->getHeader('host');
        $path = $req->getUrlParam('path');
        $cookies = $this->fetchCookieToSend($host, $path);
        if ($this !== $req) {
            $cookies = array_merge($cookies, $req->fetchCookieToSend($host, $path));
        }
        $req->setHeader('cookie', null);
        foreach (array_chunk(array_values($cookies), 3) as $chunk) {
            $req->addHeader('cookie', implode('; ', $chunk));
        }
    }
    public function fetchCookieToSend($host, $path)
    {
        $now = time();
        $host = strtolower($host);
        $cookies = [];
        $domains = ['-', $host];
        while (strlen($host) > 1 && ($pos = strpos($host, '.', 1)) !== false) {
            $host = substr($host, $pos + 1);
            $domains[] = $host;
        }
        foreach ($domains as $domain) {
            if (!isset($this->_cookies[$domain])) {
                continue;
            }
            foreach ($this->_cookies[$domain] as $_path => $list) {
                if (!strncmp($_path, $path, strlen($_path))
                    && (substr($_path, -1, 1) === '/' || substr($path, strlen($_path), 1) === '/')
                ) {
                    foreach ($list as $k => $v) {
                        if (!isset($cookies[$k]) && ($v['expires'] === null || $v['expires'] > $now)) {
                            $cookies[$k] = $k . '=' . $v['value'];
                        }
                    }
                }
            }
        }
        return $cookies;
    }
    protected function fetchCookieToSave()
    {
        $now = time();
        $cookies = [];
        foreach ($this->_cookies as $domain => $_list1) {
            $list1 = [];
            foreach ($_list1 as $path => $_list2) {
                $list2 = [];
                foreach ($_list2 as $k => $v) {
                    if ($v['expires'] === null || $v['expires'] < $now) {
                        continue;
                    }
                    $list2[$k] = $v;
                }
                if (count($list2) > 0) {
                    $list1[$path] = $list2;
                }
            }
            if (count($list1) > 0) {
                $cookies[$domain] = $list1;
            }
        }
        return $cookies;
    }
    protected function loadCookie($file)
    {
        if (file_exists($file)) {
            $this->_cookies = unserialize(file_get_contents($file));
        }
    }
    protected function saveCookie($file)
    {
        file_put_contents($file, serialize($this->fetchCookieToSave()));
    }
}
interface ParseInterface
{
    public function parse(Response $res, Request $req, $key);
}
class Processor
{
    public $key;
    public $cli;
    public $req;
    public $res;
    public $conn = null;
    public $finished;
    protected $headerOk, $timeBegin, $chunkLeft;
    public function __construct($cli, $req, $key = null)
    {
        $this->cli = $cli;
        $this->req = $req;
        $this->key = $key;
        $this->res = new Response($req->getRawUrl());
        $this->finished = $this->headerOk = false;
        $this->timeBegin = microtime(true);
    }
    public function __destruct()
    {
        if ($this->conn) {
            $this->conn->close();
        }
        $this->req = $this->cli = $this->res = $this->conn = null;
    }
    public function getConn()
    {
        if ($this->conn === null) {
            $this->conn = Connection::connect($this->req->getUrlParam('conn'), $this);
            if ($this->conn === false) {
                $this->res->error = Connection::getLastError();
                $this->finish();
            } else {
                if ($this->conn !== null) {
                    $this->conn->addWriteData($this->getRequestBuf());
                }
            }
        }
        return $this->conn;
    }
    public function send()
    {
        if ($this->conn->write() === false) {
            $this->finish('BROKEN');
        }
    }
    public function recv()
    {
        return $this->headerOk ? $this->readBody() : $this->readHeader();
    }
    public function finish($type = 'NORMAL')
    {
        $this->finished = true;
        if ($type === 'BROKEN') {
            $this->res->error = Connection::getLastError();
        } else {
            if ($type !== 'NORMAL') {
                $this->res->error = ucfirst(strtolower($type));
            }
        }
        $encoding = $this->res->getHeader('content-encoding');
        if ($encoding !== null && strstr($encoding, 'gzip')) {
            $this->res->body = Client::gzdecode($this->res->body);
        }
        $this->res->timeCost = microtime(true) - $this->timeBegin;
        $this->cli->runParser($this->res, $this->req, $this->key);
        if ($this->conn) {
            $close = $this->res->getHeader('connection');
            $this->conn->close($type !== 'NORMAL' || !strcasecmp($close, 'close'));
            $this->conn = null;
            if (($this->res->status === 301 || $this->res->status === 302)
                && $this->res->numRedirected < $this->req->getMaxRedirect()
                && ($location = $this->res->getHeader('location')) !== null
            ) {
                Client::debug('redirect to \'', $location, '\'');
                $req = $this->req;
                if (!preg_match('/^https?:\/\//i', $location)) {
                    $pa = $req->getUrlParams();
                    $url = $pa['scheme'] . '://' . $pa['host'];
                    if (isset($pa['port'])) {
                        $url .= ':' . $pa['port'];
                    }
                    if (substr($location, 0, 1) == '/') {
                        $url .= $location;
                    } else {
                        $url .= substr($pa['path'], 0, strrpos($pa['path'], '/') + 1) . $location;
                    }
                    $location = $url; 
                }
                $prevUrl = $req->getUrl();
                $req->setUrl($location);
                if (!$req->getHeader('referer')) {
                    $req->setHeader('referer', $prevUrl);
                }
                if ($req->getMethod() !== 'HEAD') {
                    $req->setMethod('GET');
                }
                $req->clearCookie();
                $req->setHeader('host', null);
                $req->setHeader('x-server-ip', null);
                $this->res->numRedirected++;
                $this->finished = $this->headerOk = false;
                return $this->res->reset();
            }
        }
        Client::debug('finished', $this->res->hasError() ? ' (' . $this->res->error . ')' : '');
        $this->req = $this->cli = null;
    }
    private function readHeader()
    {
        while (($line = $this->conn->getLine()) !== null) {
            if ($line === false) {
                return $this->finish('BROKEN');
            }
            if ($line === '') {
                $this->headerOk = true;
                $this->chunkLeft = 0;
                return $this->readBody();
            }
            Client::debug('read header line: ', $line);
            if (!strncmp('HTTP/', $line, 5)) {
                $line = trim(substr($line, strpos($line, ' ')));
                list($this->res->status, $this->res->statusText) = explode(' ', $line, 2);
                $this->res->status = intval($this->res->status);
            } else {
                if (!strncasecmp('Set-Cookie: ', $line, 12)) {
                    $cookie = $this->parseCookieLine($line);
                    if ($cookie !== false) {
                        $this->res->setRawCookie($cookie['name'], $cookie['value']);
                        $this->cli->setRawCookie($cookie['name'], $cookie['value'], $cookie['expires'], $cookie['domain'], $cookie['path']);
                    }
                } else {
                    list($k, $v) = explode(':', $line, 2);
                    $this->res->addHeader($k, trim($v));
                }
            }
        }
    }
    private function readBody()
    {
        if ($this->req->getMethod() === 'HEAD') {
            return $this->finish();
        }
        $res = $this->res;
        $conn = $this->conn;
        $length = $res->getHeader('content-length');
        $encoding = $res->getHeader('transfer-encoding');
        if ($encoding !== null && !strcasecmp($encoding, 'chunked')) {
            if ($this->chunkLeft > 0) {
                $buf = $conn->read($this->chunkLeft);
                if ($buf === false) {
                    return $this->finish('BROKEN');
                }
                if (is_string($buf)) {
                    Client::debug('read chunkLeft(', $this->chunkLeft, ')=', strlen($buf));
                    $res->body .= $buf;
                    $this->chunkLeft -= strlen($buf);
                    if ($this->chunkLeft === 0) {
                        $res->body = substr($res->body, 0, -2);
                    }
                }
                if ($this->chunkLeft > 0) {
                    return;
                }
            }
            while (($line = $conn->getLine()) !== null) {
                if ($line === false) {
                    return $this->finish('BROKEN');
                }
                Client::debug('read chunk line: ', $line);
                if (($pos = strpos($line, ';')) !== false) {
                    $line = substr($line, 0, $pos);
                }
                $size = intval(hexdec(trim($line)));
                if ($size <= 0) {
                    while ($line = $conn->getLine()) 
                    {
                        if ($line === '') {
                            break;
                        }
                        Client::debug('read tailer line: ', $line);
                        if (($pos = strpos($line, ':')) !== false) {
                            $res->addHeader(substr($line, 0, $pos), trim(substr($line, $pos + 1)));
                        }
                    }
                    return $this->finish();
                }
                $this->chunkLeft = $size + 2; 
                return;
            }
        } else {
            if ($length !== null) {
                $size = intval($length) - strlen($res->body);
                if ($size > 0) {
                    $buf = $conn->read($size);
                    if ($buf === false) {
                        return $this->finish('BROKEN');
                    }
                    if (is_string($buf)) {
                        Client::debug('read fixedBody(', $size, ')=', strlen($buf));
                        $res->body .= $buf;
                        $size -= strlen($buf);
                    }
                }
                if ($size === 0) {
                    return $this->finish();
                }
            } else {
                if ($res->body === '') {
                    $res->setHeader('connection', 'close');
                }
                if (($buf = $conn->read()) === false) {
                    return $this->finish();
                }
                if (is_string($buf)) {
                    Client::debug('read streamBody()=', strlen($buf));
                    $res->body .= $buf;
                }
            }
        }
    }
    private function parseCookieLine($line)
    {
        $now = time();
        $cookie = ['name' => '', 'value' => '', 'expires' => null, 'path' => '/'];
        $cookie['domain'] = $this->req->getHeader('host');
        $parts = explode(';', substr($line, 12));
        foreach ($parts as $part) {
            if (($pos = strpos($part, '=')) === false) {
                continue;
            }
            $k = trim(substr($part, 0, $pos));
            $v = trim(substr($part, $pos + 1));
            if ($cookie['name'] === '') {
                $cookie['name'] = $k;
                $cookie['value'] = $v;
            } else {
                $k = strtolower($k);
                if ($k === 'expires') {
                    $cookie[$k] = strtotime($v);
                    if ($cookie[$k] < $now) {
                        $cookie['value'] = '';
                    }
                } else {
                    if ($k === 'domain') {
                        $pos = strpos($cookie['domain'], $v);
                        if ($pos === 0 || substr($cookie['domain'], $pos, 1) === '.' || substr($cookie['domain'], $pos + 1, 1) === '.') {
                            $cookie[$k] = $v;
                        }
                    } else {
                        if (isset($cookie[$k])) {
                            $cookie[$k] = $v;
                        }
                    }
                }
            }
        }
        if ($cookie['name'] !== '') {
            return $cookie;
        }
        return false;
    }
    private function getRequestBuf()
    {
        $cli = $this->cli;
        $req = $this->req;
        $pa = $req->getUrlParams();
        $header = $req->getMethod() . ' ' . $pa['path'];
        if (isset($pa['query'])) {
            $header .= '?' . $pa['query'];
        }
        $header .= ' HTTP/1.1' . Client::CRLF;
        $body = $req->getBody();
        Client::debug('request body(', strlen($body) . ')');
        $cli->applyCookie($req);
        foreach (array_merge($cli->getHeader(null), $req->getHeader(null)) as $key => $value) {
            $header .= $this->formatHeaderLine($key, $value);
        }
        Client::debug('request header: ', Client::CRLF, $header);
        return $header . Client::CRLF . $body;
    }
    private function formatHeaderLine($key, $value)
    {
        if (is_array($value)) {
            $line = '';
            foreach ($value as $val) {
                $line .= $this->formatHeaderLine($key, $val);
            }
            return $line;
        }
        if (strpos($key, '-') === false) {
            $line = ucfirst($key);
        } else {
            $parts = explode('-', $key);
            $line = ucfirst($parts[0]);
            for ($i = 1; $i < count($parts); $i++) {
                $line .= '-' . ucfirst($parts[$i]);
            }
        }
        $line .= ': ' . $value . Client::CRLF;
        return $line;
    }
}
class Request
{
    use HeaderTrait;
    private $_url, $_urlParams, $_rawUrl, $_body;
    private $_method = 'GET';
    private $_maxRedirect = 5;
    private $_postFields = [];
    private $_postFiles = [];
    private static $_dns = [];
    private static $_mimes = [
        'gif' => 'image/gif', 'png' => 'image/png', 'bmp' => 'image/bmp',
        'jpeg' => 'image/jpeg', 'pjpg' => 'image/pjpg', 'jpg' => 'image/jpeg',
        'tif' => 'image/tiff', 'htm' => 'text/html', 'css' => 'text/css',
        'html' => 'text/html', 'txt' => 'text/plain', 'gz' => 'application/x-gzip',
        'tgz' => 'application/x-gzip', 'tar' => 'application/x-tar',
        'zip' => 'application/zip', 'hqx' => 'application/mac-binhex40',
        'doc' => 'application/msword', 'pdf' => 'application/pdf',
        'ps' => 'application/postcript', 'rtf' => 'application/rtf',
        'dvi' => 'application/x-dvi', 'latex' => 'application/x-latex',
        'swf' => 'application/x-shockwave-flash', 'tex' => 'application/x-tex',
        'mid' => 'audio/midi', 'au' => 'audio/basic', 'mp3' => 'audio/mpeg',
        'ram' => 'audio/x-pn-realaudio', 'ra' => 'audio/x-realaudio',
        'rm' => 'audio/x-pn-realaudio', 'wav' => 'audio/x-wav', 'wma' => 'audio/x-ms-media',
        'wmv' => 'video/x-ms-media', 'mpg' => 'video/mpeg', 'mpga' => 'video/mpeg',
        'wrl' => 'model/vrml', 'mov' => 'video/quicktime', 'avi' => 'video/x-msvideo',
    ];
    public function __construct($url = null, $method = null)
    {
        if ($url !== null) {
            $this->setUrl($url);
        }
        if ($method !== null) {
            $this->setMethod($method);
        }
    }
    public function __toString()
    {
        return $this->getUrl();
    }
    public function getMaxRedirect()
    {
        return $this->_maxRedirect;
    }
    public function setMaxRedirect($num)
    {
        $this->_maxRedirect = intval($num);
    }
    public function getRawUrl()
    {
        return $this->_rawUrl;
    }
    public function getUrl()
    {
        return $this->_url;
    }
    public function setUrl($url)
    {
        $this->_rawUrl = $url;
        if (strncasecmp($url, 'http://', 7) && strncasecmp($url, 'https://', 8) && isset($_SERVER['HTTP_HOST'])) {
            if (substr($url, 0, 1) != '/') {
                $url = substr($_SERVER['SCRIPT_NAME'], 0, strrpos($_SERVER['SCRIPT_NAME'], '/') + 1) . $url;
            }
            $url = 'http://' . $_SERVER['HTTP_HOST'] . $url;
        }
        $this->_url = str_replace('&amp;', '&', $url);
        $this->_urlParams = null;
    }
    public function getUrlParams()
    {
        if ($this->_urlParams === null) {
            $pa = @parse_url($this->getUrl());
            $pa['scheme'] = isset($pa['scheme']) ? strtolower($pa['scheme']) : 'http';
            if ($pa['scheme'] !== 'http' && $pa['scheme'] !== 'https') {
                return false;
            }
            if (!isset($pa['host'])) {
                return false;
            }
            if (!isset($pa['path'])) {
                $pa['path'] = '/';
            }
            if (isset($pa['user']) && isset($pa['pass'])) {
                $this->applyBasicAuth($pa['user'], $pa['pass']);
            }
            $port = isset($pa['port']) ? intval($pa['port']) : ($pa['scheme'] === 'https' ? 443 : 80);
            $pa['ip'] = $this->hasHeader('x-server-ip') ?
                $this->getHeader('x-server-ip') : self::getIp($pa['host']);
            $pa['conn'] = ($pa['scheme'] === 'https' ? 'ssl' : 'tcp') . '://' . $pa['ip'] . ':' . $port;
            if (!$this->hasHeader('host')) {
                $this->setHeader('host', strtolower($pa['host']));
            } else {
                $pa['host'] = $this->getHeader('host');
            }
            $this->_urlParams = $pa;
        }
        return $this->_urlParams;
    }
    public function getUrlParam($key)
    {
        $pa = $this->getUrlParams();
        return isset($pa[$key]) ? $pa[$key] : null;
    }
    public function getMethod()
    {
        return $this->_method;
    }
    public function setMethod($method)
    {
        $this->_method = strtoupper($method);
    }
    public function getBody()
    {
        $body = '';
        if ($this->_method === 'POST' || $this->_method === 'PUT') {
            if ($this->_body === null) {
                $this->_body = $this->getPostBody();
            }
            $this->setHeader('content-length', strlen($this->_body));
            $body = $this->_body . Client::CRLF;
        }
        return $body;
    }
    public function setBody($body)
    {
        $this->_body = $body;
        $this->setHeader('content-length', $body === null ? null : strlen($body));
    }
    public function setJsonBody($data)
    {
        $body = json_encode($data, JSON_UNESCAPED_UNICODE);
        $this->setHeader('content-type', 'application/json');
        $this->setBody($body);
    }
    public function addPostField($key, $value)
    {
        $this->setMethod('POST');
        $this->setBody(null);
        if (!is_array($value)) {
            $this->_postFields[$key] = strval($value);
        } else {
            $value = $this->formatArrayField($value);
            foreach ($value as $k => $v) {
                $k = $key . '[' . $k . ']';
                $this->_postFields[$k] = $v;
            }
        }
    }
    public function addPostFile($key, $file, $content = null)
    {
        $this->setMethod('POST');
        $this->setBody(null);
        if ($content === null && is_file($file)) {
            $content = @file_get_contents($file);
        }
        $this->_postFiles[$key] = [basename($file), $content];
    }
    protected function getPostBody()
    {
        $data = '';
        if (count($this->_postFiles) > 0) {
            $boundary = md5($this->_rawUrl . microtime());
            foreach ($this->_postFields as $k => $v) {
                $data .= '--' . $boundary . Client::CRLF . 'Content-Disposition: form-data; name="' . $k . '"'
                    . Client::CRLF . Client::CRLF . $v . Client::CRLF;
            }
            foreach ($this->_postFiles as $k => $v) {
                $ext = strtolower(substr($v[0], strrpos($v[0], '.') + 1));
                $type = isset(self::$_mimes[$ext]) ? self::$_mimes[$ext] : 'application/octet-stream';
                $data .= '--' . $boundary . Client::CRLF . 'Content-Disposition: form-data; name="' . $k . '"; filename="' . $v[0] . '"'
                    . Client::CRLF . 'Content-Type: ' . $type . Client::CRLF . 'Content-Transfer-Encoding: binary'
                    . Client::CRLF . Client::CRLF . $v[1] . Client::CRLF;
            }
            $data .= '--' . $boundary . '--' . Client::CRLF;
            $this->setHeader('content-type', 'multipart/form-data; boundary=' . $boundary);
        } else {
            if (count($this->_postFields) > 0) {
                foreach ($this->_postFields as $k => $v) {
                    $data .= '&' . rawurlencode($k) . '=' . rawurlencode($v);
                }
                $data = substr($data, 1);
                $this->setHeader('content-type', 'application/x-www-form-urlencoded');
            }
        }
        return $data;
    }
    protected static function getIp($host)
    {
        if (!isset(self::$_dns[$host])) {
            self::$_dns[$host] = gethostbyname($host);
        }
        return self::$_dns[$host];
    }
    private function formatArrayField($arr, $pk = null)
    {
        $ret = [];
        foreach ($arr as $k => $v) {
            if ($pk !== null) {
                $k = $pk . $k;
            }
            if (is_array($v)) {
                $ret = array_merge($ret, $this->formatArrayField($v, $k . ']['));
            } else {
                $ret[$k] = $v;
            }
        }
        return $ret;
    }
    private function applyBasicAuth($user, $pass)
    {
        $this->setHeader('authorization', 'Basic ' . base64_encode($user . ':' . $pass));
    }
}
class Response
{
    use HeaderTrait;
    public $status;
    public $statusText;
    public $error;
    public $body;
    public $timeCost;
    public $url;
    public $numRedirected = 0;
    public function __construct($url)
    {
        $this->reset();
        $this->url = $url;
    }
    public function __toString()
    {
        return $this->body;
    }
    public function hasError()
    {
        return $this->error !== null;
    }
    public function reset()
    {
        $this->status = 400;
        $this->statusText = 'Bad Request';
        $this->body = '';
        $this->error = null;
        $this->timeCost = 0;
        $this->clearHeader();
        $this->clearCookie();
    }
    public function redirect($url)
    {
        if (($this->status === 301 || $this->status === 302) && ($this->hasHeader('location'))) {
            return;
        }
        $this->numRedirected--;
        $this->status = 302;
        $this->setHeader('location', $url);
    }
    public function getJson()
    {
        if (stripos($this->getHeader('content-type'), '/json') !== false) {
            return json_decode($this->body, true);
        } else {
            return false;
        }
    }
}
